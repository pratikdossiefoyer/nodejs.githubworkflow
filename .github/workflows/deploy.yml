name: Deploy with Docker Compose
on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: self-hosted  # Using self-hosted runner that's already on your server
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      
      - name: Create Dockerfile if it doesn't exist
        run: |
          if [ ! -f Dockerfile ]; then
            cat > Dockerfile << 'EOF'
FROM node:18-alpine

WORKDIR /app

# Copy package files and install dependencies
COPY package*.json ./
RUN npm ci --production

# Copy the rest of the application
COPY . .

# Expose the port your app runs on
EXPOSE ${{ secrets.PORT }}

# Start the application
CMD ["npm", "start"]
EOF
          fi
      
      - name: Create docker-compose.yml file
        run: |
          cat > docker-compose.yml << EOF
version: '3'

services:
  api:
    build: .
    container_name: nodejs-mongo-api
    restart: unless-stopped
    ports:
      - "${{ secrets.PORT }}:${{ secrets.PORT }}"
    environment:
      - PORT=${{ secrets.PORT }}
      - MONGODB_URI=${{ secrets.MONGODB_URI }}
EOF
      
      - name: Deploy with Docker Compose
        run: |
          # Stop any running container
          docker-compose down || true
          
          # Build and start the new container
          docker-compose up -d --build
      
      - name: Verify container is running
        run: |
          sleep 5  # Give the container time to start
          if [ "$(docker ps -q -f name=nodejs-mongo-api)" ]; then
            echo "Container is running successfully"
          else
            echo "Container failed to start" >&2
            docker-compose logs
            exit 1
          fi
      
      - name: Clean up old Docker images
        run: |
          # Remove dangling images to save space
          docker image prune -f
